

새 프로젝트를 생성했습니다.

백업을 만들었습니다.


이 파일을 만들었습니다.

DirectX 프로젝트를 삭제했습니다.

DXEngine과 DXClient로 분리하였습니다.

솔루션 필터를 설정하였습니다.

백업을 만들었습니다.


클라이언트가 엔진을 참조하게 했습니다.

엔진의 출력 디렉토리를 bin으로 만들고 클라이언트의 라이브러리 디렉토리에 추가했습니다.

클라이언트의 포함 디렉토리에 엔진을 추가했습니다.

엔진을 exe에서 lib로 바꿨습니다.

기본적인 main 파일을 만들고 실행되는 것을 확인했습니다.

백업을 만들었습니다.


stdafx를 만들었습니다.

미리 컴파일된 헤더로 만들었습니다.

정상적 실행 확인, 백업 생성.


SystemClass 작성 시작.

SystemClass Frame 제외하고 작성 완료.

정상적 실행 확인, 백업.


DXClass 클래스 작성 시작.

DXClass 작성 완료.

정상 실행 확인, 백업.


이제부터 할 일.

DirectXTex 사용해 텍스처 출력.

Scene, Actor 구조 구축.


DirectXTex를 프로젝트에 추가.

DXEngine에 참조 추가. 포함 디렉터리에 추가.

DirectXTex의 출력 디렉토리를 bin으로 설정.

DXClient가 그대로 bin의 라이브러리를 사용하면 되는 것으로 보임.

정상 실행으로 정상 포함 확인, 백업.


추가 목록

tex_vs.fx (empty)
tex_ps.fx (empty)

Tex (empty)

TexShader (empty)

Scene (only SceneUpdate)


앞으로 할 일

쉐이더 코드를 작성하고

쉐이더 클래스를 만든 후

텍스처 클래스를 만들고 SceneUpdate에서 출력해 본다.

Tex 초기화는 Scene의 Start에서 수행


추가 목록

GameCore (헤더에 가상함수 Init이 전부)

목적: 엔진이 받았다가 dx 초기화 등 이후에 init 하기 위함.

GameClient (오버라이딩한 init이 전부)

정상 실행 확인, 백업.


쉐이더 코드 작성 시작. 작성 완료.

쉐이더 클래스 작성 시작. 작성 완료.

시스템에 쉐이더 클래스 Init 배치.


Tex 클래스 작성 시작. 작성 완료.

Scene에 배치해 보고 출력 테스트.

TexCom 작성, 카메라 작성.

텍스처 출력 성공.


다만 릭이 감지됨.

다음 진행하기에 앞서 릭부터 잡아야 함.


쉐이더 클래스 릴리즈.

TexCom 릴리즈. 그랬더니 릭 다 잡힘.

백업.


이미지 출력 구조를 정립했습니다. 백업. (Scale, Rot, Pos)


다만 알파값을 적용하여 출력할 필요가 있습니다.

그래도 일단은 게임 구조를 진행할 수 있을 것으로 보입니다.


Scene, Script, Actor, Com 구조를 정립하고

이를 클라이언트에서 세팅해 출력해 봅니다.

현재는 SceneUpdate만을 이용해서 출력하고 있습니다.


일단은 PlayScene을 클라이언트에 만들어서
AddScene, ChangeScene 이후
가상함수를 통해 업데이트 구조를 성공적으로 돌려보았음. 백업.


다음으로 할 일은 Scene, Actor 등의 기능을 더 구체화시키고
Player 액터를 만든 뒤 TexCom을 넣어서 돌리는 것.

이후에는 텍스처에서 투명한 부분을 처리하게끔 만들어야 됨.


기존: TexCom만 만들고 SceneUpdate에서 돌림.

변경: Script, Actor, Com 돌리는 구조 만들고 AddActor, AddCom 후 돌림.


말한 대로 Scene, Script, Actor, Com 구조 정립하고 그에 따라 텍스트 출력했음. 백업.

릭도 안 남음.


이제 텍스처를 투명하게 출력해야 됨. 물론 나중에.


텍스처 투명화 출력 시도 시작. (AR16DXE 참조)

blendState를 만들었더니 알파가 적용됐습니다. 개이득. 백업.

z 관련 여러 세팅을 건드렸습니다. 백업.


이제부터 할 일은 TexCom을 바로 출력하는 대신

Script에 예약했다가 마지막에 몰아서 렌더링하는 것입니다.

이때 z를 넣게 되며 내림차순으로 z값을 대입한 뒤 렌더링 합니다.


그 다음엔 플레이어한테 팔을 달아보고 마우스를 따라가게 해 볼 겁니다.

마우스 위치에는 카메라의 위치를 더해야 합니다. Cam::Inst의 Position 사용.


또한 충돌 Script, 컴포넌트를 짜서 충돌 구조를 만들고

FSM에 따라 액터의 행동이 달라져야 합니다.


그밖에 해야 할 것들: 애니메이션, 상호작용

하면 좋은 것들: 세이브 시스템, 맵툴, 진행도 세이브


TexScript 완료. 백업.

팔이 마우스 따라감.

회전했을 때 어깨 테두리가 하얗게 나오는 문제가 있었는데

TexShader에서 필터를 Linear에서 Point로 바꿔 해결. 백업.


이제부터 할 일은 ColCom, ColScript를 만들어서 충돌 구조를 짜는 것입니다.

이후 FSM보다는 애니메이션을 먼저 하겠습니다.


그냥 충돌 넘어가고 애니메이션부터 시작.

이름은 AniCom. TexCom의 상속을 받고,

차이점은 텍스처가 여러 개 있고 그 중에서 자유롭게 출력할 수 있단 점입니다.


AniCom 작성 완료. 백업.

현재 일일이 TexScript에 예약하는 과정이 번거롭습니다.

이를 싱글톤으로 바꾸고 Update5에서 자동으로 대기열에 추가하게 합니다.

그리고 이미지도 알파 들어간 걸로 바꿔야 합니다.


다음에 할 일은 충돌 구조를 짜는 것입니다.

애니 구조 약간 변경. 백업.


충돌 구조 하기 앞서 소리 먼저. InputClass랑.

InputClass 작성 완료. 백업.


SoundClass 작성 완료. 백업.

이제 진짜 충돌 구조.


또 그거 하기에 앞서 카메라 먼저.

이동과 줌아웃. 완료. 백업.


다음에 할 일: TexScript를 싱글톤으로 바꾸고

카메라 업데이트를 그 직전에 함.


TexScript의 이름을 RenderMgr로 바꾸고 싱글톤으로 바꿈.

그리고 이를 Update 구조에 포함시키고 TexCom이 알아서 올리게 만듬. 백업.


다만 아쉬운 건 빛이 실제로 텍스처를 비추는 게 아니라

그저 알파로 섞인다는 게 문제임.

예를 들어 흰색 빛이 닿으면
물체의 색이 그냥 더욱 진해져야 하는데
섞여서 하얗게 돼 버림. 이는 어떻게 해야 할지 생각 좀 해 봐야겠음.

빛의 색에 따라 약간 물들이는 것도 적용돼야 함.

공식을 생각해 보자면 단순 가산은 아님.
물체는 빛을 흡수하고 나머지를 반사하는데, 그 색이 물체의 색이 됨.

만약 0.0, 1.0, 0.0의 녹색 빛이 있다면 녹색의 반사 여부만 달라짐.
물체의 녹색이 1.0이라면 온전히 반사할 것이고, 0.8이라면 0.8만큼만 반사할 것임.

r이 0.1 정도 있다면 다시 r 속성의 곱셈으로 들어감.
물체의 r이 0.5라면 결과는 0.1 * 0.5.
쉐이더에서 하면 좋을 것 같긴 한데.

아 근데 진짜 구체적으로 어떻게 할진 모르겠다. 패스.


다음으로 할 것은 충돌 구조.

다만 하고 나면 TexCom, ColCom 등 컴포넌트가

액터를 따라가는 구조를 구축해야 함.

일단은 위치 정도만. 크기, 회전은 보류.


버그 발견: 줌 아웃하면 커서가 약간 엇나감.

InputClass에 IngameCursor 추가. 완료. 백업.


충돌 구조 시작.


ColMgr 작성 완료. ColCom 작성 필요.

ColMgr, ColCom, 대충 작성 완료.

다만 씬이 바뀔 때 청소 한 번 해주고

프로그램 끝날 때에도 릭을...

생각해 보니 만드는 게 아니라 참조만 하는 거라 릭은 없을 것으로 보임.

그리고 액터 자체가 뒤질 때에도 자기한테 붙은 콜리전을 빼야 함.

자기 충돌 세트 뒤져서 연결된 애들에서 전부 자기 빼줌.

이는 ColCom의 소멸자에서 해주기로. (시점은 액터 릴리즈할 때가 됨)

씬 바뀔 때 청소는 사실 그룹맵이랑 링크맵 클리어만 해도 상관 없을 듯.

어차피 액터가 모두 소멸되기 때문에 콜리전 세트 걱정도 안 해도 됨.


할 일

Scene 바뀔 때 사용할 ClearAll

ColCom 소멸자의 자기 자신 빼기
